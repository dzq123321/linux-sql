1 Linux下，没有真正意义上的多线程，Linux是用进程来模拟的线程

2 线程在进程内部运行，是进程的一个执行分支。内存运行->进程的地址空间内运行。是有独立的PCB

3  在Linux 下，进程是承担分配OS资源的基本单位，线程是CPU调度的基本单位.

在内核角度，进程是承担分配系统资源的基本单位，而线程是调度的基本单位

4  用户级线程库(pthread)，OS提供了内核的轻量级进程机制
Linux中pthread线程和内核轻量级进程是由对应关系的，1：1
5 用户级线程id是一个地址！！！
6 线程必须等待， ptrhead_join，如果不等，会有类似僵尸进程的问题
7 等待通常由主线程等待        释放资源，拿到返回结果
8  线程结束只关心返回值，代码跑完结果对或不对。不关心线程异常，因为线程异常退出后直接影响进程，使进程退出，进程返回信号
9 线程退出的3个方式：return pthread_exit  pthread_cancal()

10 检测脚本

`while :; do ps axj|head -1&&ps axj|grep thread;echo"##########"; sleep 1; done`

11、生产者消费者模型

是多线程之间一中同步和互斥的常见策略，包括2个角色，3种关系，1个交易场所。2个角色->生产者何消费者，一般有线程承担。3种关系，生产者和生产者之间的互斥关系，生产者和消费者之间的同步互斥关系，消费者之间的互斥关系。1个交易场所就是生产者和消费者之间的缓冲区。维护这个模型需要利用锁，条件变量，信号量。

12、多线程环境下，任何时候线程都有可能被调度器切走，切走的时候要保护上下文，恢复时现场恢复

13、信号量是一个计数器，本质是描述临界资源数目的计数器

14、 线程池的个数：1. 任务类型：计算密集型，IO密集型  2. 计算：线程的数量=CPU个数*每个CPU的核数 可以适度浮动    3、IO: 线程的个数>>CPU*核数  但是不建议太多    计算：如果线程过多反而可能引起效率的降低，线程间切换也是成本